"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTypeIdLengthMatch = exports.isTypeId = exports.generateTypeIdsByOutputs = exports.generateTypeIdGroup = exports.generateTypeId = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const codec_1 = require("@ckb-lumos/codec");
/**
 * Generate a TypeId based on the first input in Transaction.inputs,
 * and the index of the target cell in Transaction.outputs.
 */
function generateTypeId(firstInput, outputIndex) {
    if (!firstInput.outPoint) {
        throw new Error('Cannot generate TypeId because Transaction.inputs[0] has no OutPoint');
    }
    const script = lumos_1.utils.generateTypeIdScript({
        previousOutput: firstInput.outPoint,
        since: '0x0',
    }, lumos_1.BI.from(outputIndex).toHexString());
    return script.args;
}
exports.generateTypeId = generateTypeId;
/**
 * Generate TypeIds for a group of cells in Transaction.outputs.
 */
function generateTypeIdGroup(firstInput, outputs, filter) {
    const group = [];
    for (let i = 0; i < outputs.length; i++) {
        const isTarget = filter(outputs[i]);
        if (isTarget) {
            const groupIndex = group.length;
            group.push([i, generateTypeId(firstInput, groupIndex)]);
        }
    }
    return group;
}
exports.generateTypeIdGroup = generateTypeIdGroup;
/**
 * Generate TypeIds from a Transaction.outputs.
 *
 * This function is different from the `generateTypeIdGroup` function,
 * because this function generates TypeIds based on each output's original index in the list,
 * instead of generating them by each output's index in a group.
 */
function generateTypeIdsByOutputs(firstInput, outputs, filter) {
    function filterOutput(cell) {
        return filter instanceof Function ? filter(cell) : true;
    }
    const result = [];
    for (let i = 0; i < outputs.length; i++) {
        if (filterOutput(outputs[i])) {
            result.push([i, generateTypeId(firstInput, i)]);
        }
    }
    return result;
}
exports.generateTypeIdsByOutputs = generateTypeIdsByOutputs;
/**
 * Check if the target string is a Type ID
 */
function isTypeId(target) {
    try {
        const buf = codec_1.bytes.bytify(target);
        return buf.byteLength === 32;
    }
    catch {
        return false;
    }
}
exports.isTypeId = isTypeId;
/**
 * Check if the target string at least contains is a Type ID
 */
function isTypeIdLengthMatch(target) {
    try {
        const buf = codec_1.bytes.bytify(target);
        return buf.byteLength >= 32;
    }
    catch {
        return false;
    }
}
exports.isTypeIdLengthMatch = isTypeIdLengthMatch;
//# sourceMappingURL=typeId.js.map