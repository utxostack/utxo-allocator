"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findCellIndexByScriptFromTransactionSkeleton = exports.groupCells = exports.setupCell = exports.getCellWithStatusByOutPoint = exports.getCellByType = exports.getCellByLock = void 0;
const codec_1 = require("@ckb-lumos/codec");
const common_scripts_1 = require("@ckb-lumos/common-scripts");
const codec_2 = require("../codec");
const script_1 = require("./script");
async function getCellByLock(props) {
    const collector = props.indexer.collector({
        lock: props.lock,
    });
    for await (const cell of collector.collect()) {
        if (props.has_type && cell.cellOutput.type) {
            return cell;
        }
        else if (!props.has_type && !cell.cellOutput.type)
            return cell;
    }
    return void 0;
}
exports.getCellByLock = getCellByLock;
/**
 * Find and return the first cell of target type script from CKB Indexer.
 */
async function getCellByType(props) {
    const collector = props.indexer.collector({
        type: props.type,
    });
    for await (const cell of collector.collect()) {
        return cell;
    }
    return void 0;
}
exports.getCellByType = getCellByType;
/**
 * A wrapper function, to get a Cell structure from RPC.getLiveCell() method.
 */
async function getCellWithStatusByOutPoint(props) {
    const liveCell = await props.rpc.getLiveCell(props.outPoint, true);
    const cell = liveCell.cell
        ? {
            cellOutput: liveCell.cell.output,
            data: liveCell.cell.data.content,
            outPoint: props.outPoint,
        }
        : void 0;
    return {
        cell,
        status: liveCell.status,
    };
}
exports.getCellWithStatusByOutPoint = getCellWithStatusByOutPoint;
/**
 * Inject a cell to Transaction.inputs, and to Transaction.outputs if needed.
 * The function also adds needed/supported witness placeholders and cellDeps.
 */
async function setupCell(props) {
    // Env
    const addOutput = props.addOutput ?? false;
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Add target cell to inputs and outputs,
    // the function also handles witnesses and cellDeps
    txSkeleton = await common_scripts_1.common.setupInputCell(txSkeleton, props.input, props.fromInfo, {
        defaultWitness: props.defaultWitness,
        config: props.config,
        since: props.since,
    });
    // Remove it from outputs if not needed
    if (!addOutput) {
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            return outputs.remove(outputs.size - 1);
        });
    }
    // Indices
    const inputIndex = txSkeleton.get('inputs').size - 1;
    const outputIndex = addOutput ? txSkeleton.get('outputs').size - 1 : -1;
    // If added output, and need to update the added output
    if (addOutput && props.updateOutput instanceof Function) {
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            const output = outputs.last();
            if (!output) {
                throw new Error('Cannot update output because the added output could not be found');
            }
            return outputs.set(outputIndex, props.updateOutput(output));
        });
    }
    // If required to update the resulting witness placeholder
    if (props.updateWitness) {
        txSkeleton = txSkeleton.update('witnesses', (witnesses) => {
            if (props.updateWitness instanceof Function) {
                const witness = witnesses.get(inputIndex);
                if (!witness) {
                    throw new Error(`Cannot update Transaction.witnesses[${inputIndex}] because it's undefined`);
                }
                return witnesses.set(inputIndex, props.updateWitness(witness));
            }
            if (typeof props.updateWitness === 'string') {
                return witnesses.set(inputIndex, props.updateWitness);
            }
            return witnesses;
        });
    }
    return {
        txSkeleton,
        inputIndex,
        outputIndex,
    };
}
exports.setupCell = setupCell;
/**
 * Group cells by TypeScriptID.
 */
function groupCells(cells) {
    const groups = {};
    for (let i = 0; i < cells.length; i++) {
        const cell = cells[i];
        const scriptIdHash = cell.cellOutput.type ? codec_1.bytes.hexify(codec_2.ScriptId.pack(cell.cellOutput.type)) : 'null';
        if (groups[scriptIdHash] === void 0) {
            groups[scriptIdHash] = [];
        }
        groups[scriptIdHash].push({
            index: i,
            cell,
        });
    }
    return groups;
}
exports.groupCells = groupCells;
function findCellIndexByScriptFromTransactionSkeleton(props) {
    if (!['inputs', 'outputs'].includes(props.source)) {
        throw new Error('Can only find cell from the following source: "inputs" | "outputs"');
    }
    if (!['lock', 'type'].includes(props.scriptName)) {
        throw new Error('Can only find cell from the following scriptType: "lock" | "type"');
    }
    const list = props.txSkeleton.get(props.source);
    return list.findIndex((cell) => {
        return !!cell.cellOutput[props.scriptName] && (0, script_1.isScriptValueEquals)(cell.cellOutput[props.scriptName], props.script);
    });
}
exports.findCellIndexByScriptFromTransactionSkeleton = findCellIndexByScriptFromTransactionSkeleton;
//# sourceMappingURL=cell.js.map