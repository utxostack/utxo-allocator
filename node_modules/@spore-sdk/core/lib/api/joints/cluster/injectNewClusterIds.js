"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewClusterIds = void 0;
const helpers_1 = require("../../../helpers");
const config_1 = require("../../../config");
function injectNewClusterIds(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Get the first input
    const inputs = txSkeleton.get('inputs');
    const firstInput = inputs.get(0);
    if (!firstInput) {
        throw new Error('Cannot generate Cluster Id because Transaction.inputs[0] does not exist');
    }
    // Calculates TypeIds by the outputs' indices
    let outputs = txSkeleton.get('outputs');
    let typeIdGroup = (0, helpers_1.generateTypeIdsByOutputs)(firstInput, outputs.toArray(), (cell) => {
        return !!cell.cellOutput.type && (0, config_1.isSporeScriptSupported)(config, cell.cellOutput.type, 'Cluster');
    });
    // If `clusterOutputIndices` is provided, filter the result
    if (props.outputIndices) {
        typeIdGroup = typeIdGroup.filter(([outputIndex]) => {
            const index = props.outputIndices.findIndex((index) => index === outputIndex);
            return index >= 0;
        });
        if (typeIdGroup.length !== props.outputIndices.length) {
            throw new Error('Cannot generate Cluster Id because clusterOutputIndices cannot be fully handled');
        }
    }
    // Update results
    for (const [index, typeId] of typeIdGroup) {
        const output = outputs.get(index);
        if (!output) {
            throw new Error(`Cannot generate Cluster Id because Transaction.outputs[${index}] does not exist`);
        }
        output.cellOutput.type.args = typeId;
        outputs = outputs.set(index, output);
    }
    return txSkeleton.set('outputs', outputs);
}
exports.injectNewClusterIds = injectNewClusterIds;
//# sourceMappingURL=injectNewClusterIds.js.map