{"version":3,"file":"TransactionManager.js","names":["_base","require","_codec","_ckbIndexerFilter","_TransactionStorage","_store","TransactionManager","constructor","payload","transactionSender","cellCollectorProvider","indexer","txStorage","TransactionStorage","storage","createInMemoryStorage","clearCache","setTransactions","sendTransaction","tx","txHash","addTransaction","hash","collector","queryOptions","options","_options$usePendingOu","optionsWithoutSkip","skip","liveCellCollector","PendingCellCollector","usePendingCells","usePendingOutputs","exports","order","removePendingCell","cell","deleteTransactionByCell","cellIsSpent","spentCells","some","spent","bytes","equal","blockchain","OutPoint","pack","outPoint","collect","getSpentCellOutpoints","pendingCells","getPendingCells","filteredPendingCells","filterByLumosQueryOptions","isPendingCell"],"sources":["../src/TransactionManager.ts"],"sourcesContent":["import {\n  blockchain,\n  Transaction,\n  OutPoint,\n  Cell,\n  CellCollector,\n} from \"@ckb-lumos/base\";\nimport { bytes } from \"@ckb-lumos/codec\";\nimport { filterByLumosQueryOptions } from \"@ckb-lumos/ckb-indexer/lib/ckbIndexerFilter\";\nimport { TransactionStorage } from \"./TransactionStorage\";\nimport type { TransactionStorageType } from \"./TransactionStorage\";\nimport { createInMemoryStorage, Promisable, Store } from \"./store\";\nimport type { CKBIndexerQueryOptions } from \"@ckb-lumos/ckb-indexer/lib/type\";\n\ninterface TransactionManagerType {\n  sendTransaction(tx: Transaction): Promisable<string>;\n  collector(\n    queryOptions: CKBIndexerQueryOptions,\n    options?: { usePendingOutputs?: boolean }\n  ): CellCollector;\n  clearCache(): Promisable<void>;\n}\n\ninterface TransactionSender {\n  sendTransaction(tx: Transaction): Promisable<string>;\n}\n\ninterface LumosCellIndexer {\n  collector(options: CKBIndexerQueryOptions): CellCollector;\n}\n\ntype ServiceProviders = {\n  transactionSender: TransactionSender;\n  indexer: LumosCellIndexer;\n};\n\ntype ServiceEndPoint = {\n  rpcUrl: string;\n};\n\n/**\n * `TransactionManager` offer a simple way to query and cache the pending transactions,\n * it means you can get the pending cells without waiting for the transaction to be confirmed.\n */\nexport class TransactionManager implements TransactionManagerType {\n  private transactionSender: TransactionSender;\n  private cellCollectorProvider: LumosCellIndexer;\n  private txStorage: TransactionStorageType;\n\n  constructor(payload: {\n    transactionSender: TransactionSender;\n    indexer: LumosCellIndexer;\n    storage?: Store;\n  }) {\n    this.transactionSender = payload.transactionSender;\n    this.cellCollectorProvider = payload.indexer;\n\n    this.txStorage = new TransactionStorage(\n      payload.storage || createInMemoryStorage()\n    );\n  }\n\n  async clearCache(): Promise<void> {\n    await this.txStorage.setTransactions([]);\n  }\n\n  async sendTransaction(tx: Transaction): Promise<string> {\n    const txHash = await this.transactionSender.sendTransaction(tx);\n    await this.txStorage.addTransaction({ ...tx, hash: txHash });\n    return txHash;\n  }\n\n  /**\n   * Similar to `ckbIndexer.collector`, but it will return the pending cells as well.\n   * You can use `usePendingOutputs` to control whether to return the pending cells.\n   * @param queryOptions\n   * @param options\n   */\n  collector(\n    queryOptions: CKBIndexerQueryOptions,\n    options?: {\n      /**\n       * @default true\n       */\n      usePendingOutputs?: boolean;\n    }\n  ): CellCollector {\n    const optionsWithoutSkip = {\n      ...queryOptions,\n      skip: 0,\n    };\n    const liveCellCollector =\n      this.cellCollectorProvider.collector(optionsWithoutSkip);\n    return new PendingCellCollector({\n      txStorage: this.txStorage,\n      queryOptions: optionsWithoutSkip,\n      usePendingCells: options?.usePendingOutputs ?? true,\n      liveCellCollector,\n    });\n  }\n}\n\nclass PendingCellCollector implements CellCollector {\n  private txStorage: TransactionStorageType;\n  private queryOptions: CKBIndexerQueryOptions;\n  private liveCellCollector: CellCollector;\n  private usePendingCells: boolean;\n  /**\n   * @param order - default to asc, return on-chain cells first, then pending cells, and vice versa\n   */\n  private order: \"asc\" | \"desc\";\n\n  constructor(payload: {\n    txStorage: TransactionStorageType;\n    queryOptions: CKBIndexerQueryOptions;\n    liveCellCollector: CellCollector;\n    usePendingCells: boolean;\n  }) {\n    const { queryOptions, liveCellCollector, txStorage, usePendingCells } =\n      payload;\n\n    this.order = queryOptions.order === \"desc\" ? \"desc\" : \"asc\";\n    this.liveCellCollector = liveCellCollector;\n    this.usePendingCells = usePendingCells;\n    this.txStorage = txStorage;\n    this.queryOptions = queryOptions;\n  }\n\n  private async removePendingCell(cell: Cell): Promise<boolean> {\n    return await this.txStorage.deleteTransactionByCell(cell);\n  }\n\n  private cellIsSpent(cell: Cell, spentCells: OutPoint[]): boolean {\n    return spentCells.some((spent) =>\n      bytes.equal(\n        blockchain.OutPoint.pack(spent),\n        blockchain.OutPoint.pack(cell.outPoint!)\n      )\n    );\n  }\n\n  async *collect(): AsyncGenerator<Cell> {\n    const spentCells: OutPoint[] = await this.txStorage.getSpentCellOutpoints();\n\n    // order is desc, return pending cells first, then on-chain cells\n    if (this.order === \"desc\") {\n      if (this.usePendingCells) {\n        const pendingCells: Cell[] = await this.txStorage.getPendingCells();\n        const filteredPendingCells = filterByLumosQueryOptions(\n          pendingCells,\n          this.queryOptions\n        );\n        for (const cell of filteredPendingCells) {\n          if (!this.cellIsSpent(cell, spentCells)) {\n            yield cell;\n          }\n        }\n      }\n      for await (const cell of this.liveCellCollector.collect()) {\n        const isPendingCell = await this.removePendingCell(cell);\n        if (!this.cellIsSpent(cell, spentCells) && !isPendingCell) {\n          yield cell;\n        }\n      }\n      // orser is asc, return on-chain cells first, then pending cells\n    } else {\n      for await (const cell of this.liveCellCollector.collect()) {\n        await this.removePendingCell(cell);\n        if (!this.cellIsSpent(cell, spentCells)) {\n          yield cell;\n        }\n      }\n      const pendingCells: Cell[] = await this.txStorage.getPendingCells();\n      const filteredPendingCells = filterByLumosQueryOptions(\n        pendingCells,\n        this.queryOptions\n      );\n      if (this.usePendingCells) {\n        for (const cell of filteredPendingCells) {\n          if (!this.cellIsSpent(cell, spentCells)) {\n            yield cell;\n          }\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"}