{"version":3,"file":"base.js","names":["_utils","require","_bytes","createBytesCodec","codec","pack","unpacked","unpack","bytesLike","bytify","isFixedCodec","isObjectLike","__isFixedCodec__","createFixedBytesCodec","byteLength","u","packed","assertBufferLength","buf"],"sources":["../src/base.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { assertBufferLength, isObjectLike } from \"./utils\";\nimport { bytify } from \"./bytes\";\n\nexport interface Codec<\n  Packed,\n  Unpacked,\n  Packable = Unpacked,\n  Unpackable = Packed\n> {\n  pack: (packable: Packable) => Packed;\n  unpack: (unpackable: Unpackable) => Unpacked;\n}\n\nexport type AnyCodec = Codec<any, any>;\n\nexport type PackResult<T extends AnyCodec> = T extends Codec<\n  infer Packed,\n  any,\n  any,\n  any\n>\n  ? Packed\n  : never;\nexport type PackParam<T extends AnyCodec> = T extends Codec<\n  any,\n  any,\n  infer Packable,\n  any\n>\n  ? Packable\n  : never;\n\nexport type UnpackResult<T extends AnyCodec> = T extends Codec<\n  any,\n  infer Unpacked,\n  any,\n  any\n>\n  ? Unpacked\n  : never;\n\nexport type UnpackParam<T extends AnyCodec> = T extends Codec<\n  any,\n  any,\n  any,\n  infer Unpackable\n>\n  ? Unpackable\n  : never;\n\nexport type Uint8ArrayCodec<Unpacked = any, Packable = Unpacked> = Codec<\n  Uint8Array,\n  Unpacked,\n  Packable\n>;\n\nexport type BytesLike = ArrayLike<number> | ArrayBuffer | string;\n\nexport type BytesCodec<Unpacked = any, Packable = Unpacked> = Codec<\n  Uint8Array,\n  Unpacked,\n  Packable,\n  BytesLike\n>;\n\n/**\n * Create a codec to deal with bytes-like data.\n * @param codec\n */\nexport function createBytesCodec<Unpacked, Packable = Unpacked>(\n  codec: Uint8ArrayCodec<Unpacked, Packable>\n): BytesCodec<Unpacked, Packable> {\n  return {\n    pack: (unpacked) => codec.pack(unpacked),\n    unpack: (bytesLike) => codec.unpack(bytify(bytesLike)),\n  };\n}\n\nexport type Fixed = {\n  readonly __isFixedCodec__: true;\n  readonly byteLength: number;\n};\n\nexport type FixedBytesCodec<Unpacked = any, Packable = Unpacked> = BytesCodec<\n  Unpacked,\n  Packable\n> &\n  Fixed;\n\nexport function isFixedCodec<T>(\n  codec: BytesCodec<T>\n): codec is FixedBytesCodec<T> {\n  return isObjectLike(codec) && !!codec.__isFixedCodec__;\n}\n\nexport function createFixedBytesCodec<Unpacked, Packable = Unpacked>(\n  codec: Uint8ArrayCodec<Unpacked, Packable> & { byteLength: number }\n): FixedBytesCodec<Unpacked, Packable> {\n  const byteLength = codec.byteLength;\n  return {\n    __isFixedCodec__: true,\n    byteLength,\n    ...createBytesCodec({\n      pack: (u) => {\n        const packed = codec.pack(u);\n        assertBufferLength(packed, byteLength);\n        return packed;\n      },\n      unpack: (buf) => {\n        assertBufferLength(buf, byteLength);\n        return codec.unpack(buf);\n      },\n    }),\n  };\n}\n"],"mappings":";;;;;;;;AACA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AAFA;;AAkEA;AACA;AACA;AACA;AACO,SAASE,gBAAgBA,CAC9BC,KAA0C,EACV;EAChC,OAAO;IACLC,IAAI,EAAGC,QAAQ,IAAKF,KAAK,CAACC,IAAI,CAACC,QAAQ,CAAC;IACxCC,MAAM,EAAGC,SAAS,IAAKJ,KAAK,CAACG,MAAM,CAAC,IAAAE,aAAM,EAACD,SAAS,CAAC;EACvD,CAAC;AACH;AAaO,SAASE,YAAYA,CAC1BN,KAAoB,EACS;EAC7B,OAAO,IAAAO,mBAAY,EAACP,KAAK,CAAC,IAAI,CAAC,CAACA,KAAK,CAACQ,gBAAgB;AACxD;AAEO,SAASC,qBAAqBA,CACnCT,KAAmE,EAC9B;EACrC,MAAMU,UAAU,GAAGV,KAAK,CAACU,UAAU;EACnC,OAAO;IACLF,gBAAgB,EAAE,IAAI;IACtBE,UAAU;IACV,GAAGX,gBAAgB,CAAC;MAClBE,IAAI,EAAGU,CAAC,IAAK;QACX,MAAMC,MAAM,GAAGZ,KAAK,CAACC,IAAI,CAACU,CAAC,CAAC;QAC5B,IAAAE,yBAAkB,EAACD,MAAM,EAAEF,UAAU,CAAC;QACtC,OAAOE,MAAM;MACf,CAAC;MACDT,MAAM,EAAGW,GAAG,IAAK;QACf,IAAAD,yBAAkB,EAACC,GAAG,EAAEJ,UAAU,CAAC;QACnC,OAAOV,KAAK,CAACG,MAAM,CAACW,GAAG,CAAC;MAC1B;IACF,CAAC;EACH,CAAC;AACH"}