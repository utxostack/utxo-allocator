{"version":3,"file":"layout.js","names":["_base","require","_number","_bytes","_error","_highOrder","array","itemCodec","itemCount","enhancedArrayCodec","createArrayCodec","createFixedBytesCodec","byteLength","pack","items","itemsBuf","concat","unpack","buf","result","itemLength","offset","push","slice","diff","x1","x2","filter","x","includes","checkShape","shape","fields","shapeKeys","Object","keys","missingFields","missingShape","length","Error","join","struct","objectCodec","createObjectCodec","reduce","sum","field","obj","packed","Uint8Array","from","forEach","itemBuf","assign","fixvec","createBytesCodec","arrayCodec","Uint32LE","item","ArrayBuffer","dynvec","packedHeader","header","body","packedTotalSize","totalSize","offset0","offsets","Array","fill","map","_","index","start","end","vector","isFixedCodec","table","headerLength","packedObj","packedItem","packedOffset","union","isArray","ids","values","Set","size","availableFields","type","typeName","CodecBaseParseError","fieldId","indexOf","String","packedFieldIndex","packedBody","value","entry","entries","find","id","option","nullableCodec","createNullableCodec","undefined"],"sources":["../../src/molecule/layout.ts"],"sourcesContent":["/**\n * |  Type  |                      Header                      |               Body                |\n * |--------+--------------------------------------------------+-----------------------------------|\n * | array  |                                                  |  item-0 |  item-1 | ... |  item-N |\n * | struct |                                                  | field-0 | field-1 | ... | field-N |\n * | fixvec | items-count                                      |  item-0 |  item-1 | ... |  item-N |\n * | dynvec | full-size | offset-0 | offset-1 | ... | offset-N |  item-0 |  item-1 | ... |  item-N |\n * | table  | full-size | offset-0 | offset-1 | ... | offset-N | filed-0 | field-1 | ... | field-N |\n * | option |                                                  | item or none (zero bytes)         |\n * | union  | item-type-id                                     | item                              |\n */\n\nimport {\n  BytesCodec,\n  Fixed,\n  FixedBytesCodec,\n  PackParam,\n  UnpackResult,\n  createBytesCodec,\n  createFixedBytesCodec,\n  isFixedCodec,\n} from \"../base\";\nimport { Uint32LE } from \"../number\";\nimport { concat } from \"../bytes\";\nimport { CodecBaseParseError } from \"../error\";\nimport {\n  createObjectCodec,\n  createArrayCodec,\n  createNullableCodec,\n} from \"../high-order\";\n\ntype NullableKeys<O extends Record<string, unknown>> = {\n  [K in keyof O]-?: [O[K] & (undefined | null)] extends [never] ? never : K;\n}[keyof O];\ntype NonNullableKeys<O extends Record<string, unknown>> = {\n  [K in keyof O]-?: [O[K] & (undefined | null)] extends [never] ? K : never;\n}[keyof O];\n\n// prettier-ignore\ntype PartialNullable<O extends Record<string, unknown>> =\n  & Partial<Pick<O, NullableKeys<O>>>\n  & Pick<O, NonNullableKeys<O>>;\n\n/**\n * A codec for struct and table of Molecule\n */\nexport type ObjectLayoutCodec<T extends Record<string, BytesCodec>> =\n  BytesCodec<\n    PartialNullable<{ [key in keyof T]: UnpackResult<T[key]> }>,\n    PartialNullable<{ [key in keyof T]: PackParam<T[key]> }>\n  >;\n\n/**\n * A codec for option of Molecule\n */\nexport interface OptionLayoutCodec<T extends BytesCodec>\n  extends BytesCodec<UnpackResult<T> | undefined> {\n  pack: (packable?: PackParam<T>) => Uint8Array;\n}\n\n/**\n * A code for array and vector of Molecule\n */\nexport type ArrayLayoutCodec<T extends BytesCodec> = BytesCodec<\n  Array<UnpackResult<T>>,\n  Array<PackParam<T>>\n>;\n\n/**\n * A molecule codec for `\n */\nexport type UnionLayoutCodec<T extends Record<string, BytesCodec>> = BytesCodec<\n  { [key in keyof T]: { type: key; value: UnpackResult<T[key]> } }[keyof T],\n  { [key in keyof T]: { type: key; value: PackParam<T[key]> } }[keyof T]\n>;\n\n/**\n * The array is a fixed-size type: it has a fixed-size inner type and a fixed length.\n * The size of an array is the size of inner type times the length.\n * @param itemCodec the fixed-size array item codec\n * @param itemCount\n */\nexport function array<T extends FixedBytesCodec>(\n  itemCodec: T,\n  itemCount: number\n): ArrayLayoutCodec<T> & Fixed {\n  const enhancedArrayCodec = createArrayCodec(itemCodec);\n  return createFixedBytesCodec({\n    byteLength: itemCodec.byteLength * itemCount,\n    pack(items) {\n      const itemsBuf = enhancedArrayCodec.pack(items);\n      return concat(...itemsBuf);\n    },\n    unpack(buf) {\n      const result: UnpackResult<T>[] = [];\n      const itemLength = itemCodec.byteLength;\n      for (let offset = 0; offset < buf.byteLength; offset += itemLength) {\n        result.push(itemCodec.unpack(buf.slice(offset, offset + itemLength)));\n      }\n      return result;\n    },\n  });\n}\n\nfunction diff(x1: unknown[], x2: unknown[]) {\n  return x1.filter((x) => !x2.includes(x));\n}\n\nfunction checkShape<T extends object>(shape: T, fields: (keyof T)[]) {\n  const shapeKeys = Object.keys(shape) as (keyof T)[];\n\n  const missingFields = diff(shapeKeys, fields);\n  const missingShape = diff(fields, shapeKeys);\n\n  if (missingFields.length > 0 || missingShape.length > 0) {\n    throw new Error(\n      `Invalid shape: missing fields ${missingFields.join(\n        \", \"\n      )} or shape ${missingShape.join(\", \")}`\n    );\n  }\n}\n\n/**\n * Struct is a fixed-size type: all fields in struct are fixed-size and it has a fixed quantity of fields.\n * The size of a struct is the sum of all fields' size.\n * @param shape a object contains all fields' codec\n * @param fields the shape's keys. It provide an order for serialization/deserialization.\n */\nexport function struct<T extends Record<string, FixedBytesCodec>>(\n  shape: T,\n  fields: (keyof T)[]\n): ObjectLayoutCodec<T> & Fixed {\n  checkShape(shape, fields);\n  const objectCodec = createObjectCodec(shape);\n  return createFixedBytesCodec({\n    byteLength: fields.reduce((sum, field) => sum + shape[field].byteLength, 0),\n    pack(obj) {\n      const packed = objectCodec.pack(\n        obj as { [K in keyof T]: PackParam<T[K]> }\n      );\n      return fields.reduce((result, field) => {\n        return concat(result, packed[field]);\n      }, Uint8Array.from([]));\n    },\n    unpack(buf) {\n      const result = {} as PartialNullable<{\n        [key in keyof T]: UnpackResult<T[key]>;\n      }>;\n      let offset = 0;\n\n      fields.forEach((field) => {\n        const itemCodec = shape[field];\n        const itemBuf = buf.slice(offset, offset + itemCodec.byteLength);\n        Object.assign(result, { [field]: itemCodec.unpack(itemBuf) });\n\n        offset = offset + itemCodec.byteLength;\n      });\n\n      return result;\n    },\n  });\n}\n\n/**\n * Vector with fixed size item codec\n * @param itemCodec fixed-size vector item codec\n */\nexport function fixvec<T extends FixedBytesCodec>(\n  itemCodec: T\n): ArrayLayoutCodec<T> {\n  return createBytesCodec({\n    pack(items) {\n      const arrayCodec = createArrayCodec(itemCodec);\n      return concat(\n        Uint32LE.pack(items.length),\n        arrayCodec\n          .pack(items)\n          .reduce((buf, item) => concat(buf, item), new ArrayBuffer(0))\n      );\n    },\n    unpack(buf) {\n      if (buf.byteLength < 4) {\n        throw new Error(\n          `fixvec: buffer is too short, expected at least 4 bytes, got ${buf.byteLength}`\n        );\n      }\n      const itemCount = Uint32LE.unpack(buf.slice(0, 4));\n      return array(itemCodec, itemCount).unpack(buf.slice(4));\n    },\n  });\n}\n\n/**\n * Vector with dynamic size item codec\n * @param itemCodec the vector item codec. It can be fixed-size or dynamic-size.\n * For example, you can create a recursive vector with this.\n */\nexport function dynvec<T extends BytesCodec>(\n  itemCodec: T\n): ArrayLayoutCodec<T> {\n  return createBytesCodec({\n    pack(obj) {\n      const arrayCodec = createArrayCodec(itemCodec);\n      const packed = arrayCodec.pack(obj).reduce(\n        (result, item) => {\n          const packedHeader = Uint32LE.pack(result.offset);\n          return {\n            header: concat(result.header, packedHeader),\n            body: concat(result.body, item),\n            offset: result.offset + item.byteLength,\n          };\n        },\n        {\n          header: new ArrayBuffer(0),\n          body: new ArrayBuffer(0),\n          offset: 4 + obj.length * 4,\n        }\n      );\n      const packedTotalSize = Uint32LE.pack(\n        packed.header.byteLength + packed.body.byteLength + 4\n      );\n      return concat(packedTotalSize, packed.header, packed.body);\n    },\n    unpack(buf) {\n      const totalSize = Uint32LE.unpack(buf.slice(0, 4));\n      if (totalSize !== buf.byteLength) {\n        throw new Error(\n          `Invalid buffer size, read from header: ${totalSize}, actual: ${buf.byteLength}`\n        );\n      }\n      const result: UnpackResult<T>[] = [];\n      if (totalSize <= 4) {\n        return result;\n      } else {\n        const offset0 = Uint32LE.unpack(buf.slice(4, 8));\n        const itemCount = (offset0 - 4) / 4;\n        const offsets = new Array(itemCount)\n          .fill(1)\n          .map((_, index) =>\n            Uint32LE.unpack(buf.slice(4 + index * 4, 8 + index * 4))\n          );\n        offsets.push(totalSize);\n        const result: UnpackResult<T>[] = [];\n        for (let index = 0; index < offsets.length - 1; index++) {\n          const start = offsets[index];\n          const end = offsets[index + 1];\n          const itemBuf = buf.slice(start, end);\n          result.push(itemCodec.unpack(itemBuf));\n        }\n        return result;\n      }\n    },\n  });\n}\n\n/**\n * General vector codec, if `itemCodec` is fixed size type, it will create a fixvec codec, otherwise a dynvec codec will be created.\n * @param itemCodec\n */\nexport function vector<T extends BytesCodec>(\n  itemCodec: T\n): ArrayLayoutCodec<T> {\n  if (isFixedCodec(itemCodec)) {\n    return fixvec(itemCodec);\n  }\n  return dynvec(itemCodec);\n}\n\n/**\n * Table is a dynamic-size type. It can be considered as a dynvec but the length is fixed.\n * @param shape The table shape, item codec can be dynamic size\n * @param fields the shape's keys. Also provide an order for pack/unpack.\n */\nexport function table<T extends Record<string, BytesCodec>>(\n  shape: T,\n  fields: (keyof T)[]\n): ObjectLayoutCodec<T> {\n  checkShape(shape, fields);\n  return createBytesCodec({\n    pack(obj) {\n      const headerLength = 4 + fields.length * 4;\n      const objectCodec = createObjectCodec(shape);\n      const packedObj = objectCodec.pack(\n        obj as { [K in keyof T]: PackParam<T[K]> }\n      );\n      const packed = fields.reduce(\n        (result, field) => {\n          const packedItem = packedObj[field];\n          const packedOffset = Uint32LE.pack(result.offset);\n          return {\n            header: concat(result.header, packedOffset),\n            body: concat(result.body, packedItem),\n            offset: result.offset + packedItem.byteLength,\n          };\n        },\n        {\n          header: new ArrayBuffer(0),\n          body: new ArrayBuffer(0),\n          offset: headerLength,\n        }\n      );\n      const packedTotalSize = Uint32LE.pack(\n        packed.header.byteLength + packed.body.byteLength + 4\n      );\n      return concat(packedTotalSize, packed.header, packed.body);\n    },\n    unpack(buf) {\n      const totalSize = Uint32LE.unpack(buf.slice(0, 4));\n      if (totalSize !== buf.byteLength) {\n        throw new Error(\n          `Invalid buffer size, read from header: ${totalSize}, actual: ${buf.byteLength}`\n        );\n      }\n      if (totalSize <= 4 || fields.length === 0) {\n        return {} as PartialNullable<{\n          [key in keyof T]: UnpackResult<T[key]>;\n        }>;\n      } else {\n        const offsets = fields.map((_, index) =>\n          Uint32LE.unpack(buf.slice(4 + index * 4, 8 + index * 4))\n        );\n        offsets.push(totalSize);\n        const obj = {};\n        for (let index = 0; index < offsets.length - 1; index++) {\n          const start = offsets[index];\n          const end = offsets[index + 1];\n          const field = fields[index];\n          const itemCodec = shape[field];\n          const itemBuf = buf.slice(start, end);\n          Object.assign(obj, { [field]: itemCodec.unpack(itemBuf) });\n        }\n        return obj as PartialNullable<{\n          [key in keyof T]: UnpackResult<T[key]>;\n        }>;\n      }\n    },\n  });\n}\n\n/**\n * Union is a dynamic-size type.\n * Serializing a union has two steps:\n * - Serialize an item type id in bytes as a 32 bit unsigned integer in little-endian. The item type id is the index of the inner items, and it's starting at 0.\n * - Serialize the inner item.\n * @param itemCodec the union item record\n * @param fields the union item keys, can be an array or an object with custom id\n * @example\n * // without custom id\n * union({ cafe: Uint8, bee: Uint8 }, ['cafe', 'bee'])\n * // with custom id\n * union({ cafe: Uint8, bee: Uint8 }, { cafe: 0xcafe, bee: 0xbee })\n */\nexport function union<T extends Record<string, BytesCodec>>(\n  itemCodec: T,\n  fields: (keyof T)[] | Record<keyof T, number>\n): UnionLayoutCodec<T> {\n  checkShape(itemCodec, Array.isArray(fields) ? fields : Object.keys(fields));\n\n  // check duplicated id\n  if (!Array.isArray(fields)) {\n    const ids = Object.values(fields);\n    if (ids.length !== new Set(ids).size) {\n      throw new Error(`Duplicated id in union: ${ids.join(\", \")}`);\n    }\n  }\n\n  return createBytesCodec({\n    pack(obj) {\n      const availableFields: (keyof T)[] = Object.keys(itemCodec);\n\n      const type = obj.type;\n      const typeName = `Union(${availableFields.join(\" | \")})`;\n\n      /* c8 ignore next */\n      if (typeof type !== \"string\") {\n        throw new CodecBaseParseError(\n          `Invalid type in union, type must be a string`,\n          typeName\n        );\n      }\n\n      const fieldId = Array.isArray(fields)\n        ? fields.indexOf(type)\n        : fields[type];\n\n      if (fieldId < 0) {\n        throw new CodecBaseParseError(\n          `Unknown union type: ${String(obj.type)}`,\n          typeName\n        );\n      }\n      const packedFieldIndex = Uint32LE.pack(fieldId);\n      const packedBody = itemCodec[type].pack(obj.value);\n      return concat(packedFieldIndex, packedBody);\n    },\n    unpack(buf) {\n      const fieldId = Uint32LE.unpack(buf.slice(0, 4));\n\n      const type: keyof T | undefined = (() => {\n        if (Array.isArray(fields)) {\n          return fields[fieldId];\n        }\n\n        const entry = Object.entries(fields).find(([, id]) => id === fieldId);\n        return entry?.[0];\n      })();\n\n      if (!type) {\n        throw new Error(\n          `Unknown union field id: ${fieldId}, only ${fields} are allowed`\n        );\n      }\n\n      return { type, value: itemCodec[type].unpack(buf.slice(4)) };\n    },\n  });\n}\n\n/**\n * Option is a dynamic-size type.\n * Serializing an option depends on whether it is empty or not:\n * - if it's empty, there is zero bytes (the size is 0).\n * - if it's not empty, just serialize the inner item (the size is same as the inner item's size).\n * @param itemCodec\n */\nexport function option<T extends BytesCodec>(\n  itemCodec: T\n): OptionLayoutCodec<T> {\n  return createBytesCodec({\n    pack(obj?) {\n      const nullableCodec = createNullableCodec(itemCodec);\n      if (obj !== undefined && obj !== null) {\n        return nullableCodec.pack(obj);\n      } else {\n        return Uint8Array.from([]);\n      }\n    },\n    unpack(buf) {\n      if (buf.byteLength === 0) {\n        return undefined;\n      }\n      return itemCodec.unpack(buf);\n    },\n  });\n}\n"],"mappings":"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"}